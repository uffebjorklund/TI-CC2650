<?xml version="1.0"?>
<doc>
    <assembly>
        <name>XSockets.Core.Common</name>
    </assembly>
    <members>
        <member name="T:XSockets.Core.Common.Configuration.IConfigurationSetting">
            <summary>
            Describes a XSockets server configuration
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Configuration.IConfigurationSetting.BacklogSize">
            <summary>
            Backlog size for listening socket
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Configuration.IConfigurationSetting.ThreadPoolSize">
            <summary>
            The minimum number of worker threads that the thread pool creates on demand.
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Configuration.IConfigurationSetting.CompletionPortThreads">
            <summary>
            The minimum number of asynchronous I/O threads that the thread pool creates on demand.
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Configuration.IConfigurationSetting.Uri">
            <summary>
            The configuration endpoint, if having both public and private endpoints this represents the public endpoint
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Configuration.IConfigurationSetting.Origin">
            <summary>
            The origins allowed to connect to the server
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Configuration.IConfigurationSetting.CertificateSubjectDistinguishedName">
            <summary>
            
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Configuration.IConfigurationSetting.CertificateLocation">
            <summary>
            
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Configuration.IConfigurationSetting.Certificate">
            <summary>
            
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Configuration.IConfigurationSetting.Endpoint">
            <summary>
            The exposed endpoint
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Configuration.IConfigurationSetting.IsSecure">
            <summary>
            TLS/SSL flag
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Configuration.IConfigurationSetting.ForceClientCertificate">
            <summary>
            Set to true to force the clients to use a cert for SSL
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Enterprise.IXSocketsScaleOut">
            <summary>
            Default scaleout of XSockets
            Will scale over TCP/IP sockets
            
            Derive from XSockets.Enterprise.BaseScaleOut to implement your own scaleout
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Enterprise.IXSocketsScaleOut.Init">
            <summary>
            Will be called by the BaseScaleOut constructor.
            Initialize things for your scaleout here if needed
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Enterprise.IXSocketsScaleOut.Publish(XSockets.Core.Common.Socket.Event.Interface.IMessage)">
            <summary>
            Will be called when a message arrives into XSockets (if scaling is enabled)
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:XSockets.Core.Common.Enterprise.IXSocketsScaleOut.Subscribe">
            <summary>
            Will be called by the BaseScaleOut constructor (after the call to Init)
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Enterprise.IXSocketsScaleOut.AddScaleOut(System.String)">
            <summary>
            For adding a new server in the scaleout
            </summary>
            <param name="connectionstring"></param>
        </member>
        <member name="M:XSockets.Core.Common.Enterprise.IXSocketsScaleOut.RemoveScaleOut(System.String)">
            <summary>
            For removing a server from the scaleout
            </summary>
            <param name="connectionstring"></param>
        </member>
        <member name="T:XSockets.Core.Common.Enterprise.IXSocketsScaleOutConfig">
            <summary>
            Simple class for information about scaleout servers
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Enterprise.IXSocketsScaleOutConfig.Connectionstring">
            <summary>
            Connector to the scaleout
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Factories.IXSocketFactory">
            <summary>
            Handles controllers instances/creation
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Factories.IXSocketFactory.GetPluginById(System.String)">
            <summary>
            Get the exported plugin based on alias
            </summary>
            <param name="alias"></param>
            <returns></returns>
        </member>
        <member name="M:XSockets.Core.Common.Factories.IXSocketFactory.GetPluginByType(System.Type)">
            <summary>
            Get the exported plugin base don type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:XSockets.Core.Common.Factories.IXSocketFactory.AddPlugin(XSockets.Core.Common.Socket.IXSocketController,XSockets.Plugin.Framework.Attributes.IXSocketMetadata)">
            <summary>
            Registers a plugin in the factory and also sets custom events if there is any.
            </summary>
            <param name="plugin"></param>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:XSockets.Core.Common.Factories.IXSocketFactory.RemovePlugin(XSockets.Core.Common.Socket.IXSocketController)">
            <summary>
            Removes the plugin from the factory
            </summary>
            <param name="plugin"></param>
        </member>
        <member name="M:XSockets.Core.Common.Factories.IXSocketFactory.Create(XSockets.Core.Common.Socket.IXSocketController)">
            <summary>
            Creates a controller instance from the controller passed in
            </summary>
            <param name="t">A instance of the type to duplicate</param>
            <returns>A new IXSocketsController of the type passed in</returns>
        </member>
        <member name="M:XSockets.Core.Common.Factories.IXSocketFactory.GetCustomEvents(XSockets.Core.Common.Socket.IXSocketController)">
            <summary>
            Returns all custom events (action methods) registered in the controller class.
            </summary>
            <param name="plugin"></param>
            <returns></returns>
        </member>
        <member name="T:XSockets.Core.Common.Factories.IXSocketProtocolFactory">
            <summary>
            Handles protocol instances/creation
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Factories.IXSocketProtocolFactory.AddPlugin(XSockets.Core.Common.Protocol.IXSocketProtocol,XSockets.Core.Common.Configuration.IConfigurationSetting)">
            <summary>
            Register a protocol in the factory
            </summary>
            <param name="protocol">protocol to add</param>
            <param name="configurationSetting">configuration for server</param>
            <returns>true if success, else false</returns>
        </member>
        <member name="P:XSockets.Core.Common.Factories.IXSocketProtocolFactory.Protocols">
            <summary>
            All registered protocols
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Globals.Constants">
            <summary>
            Constants within XSockets
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Globals.Constants.GenericController">
            <summary>
            The name of the built-in controller
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Globals.Constants.ClusterController">
            <summary>
            The name of the built-in controller for scaling 
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Globals.Constants.GenericTextBufferSize">
            <summary>
            Default buffer size for messages
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Globals.Constants.Connection">
            <summary>
            Connection constants
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Globals.Constants.Connection.Parameters">
            <summary>
            Connection parameter constants
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Globals.Constants.Connection.Parameters.PersistentId">
            <summary>
            Constant for PersistentId
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Globals.Constants.Messages">
            <summary>
            Constants for built-in messages
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Globals.Constants.Messages.UnknownController">
            <summary>
            The message to send if a client tries to connect to a non-existing controller
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Globals.Constants.Security">
            <summary>
            Security (protocol) constants
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Globals.Constants.Security.Seckeyaaccept">
            <summary>
            Secure Key Accept when building host response
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Globals.Constants.Events">
            <summary>
            Constants for built-in events/topics
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Globals.Constants.Events.Error">
            <summary>
            The topic for Error
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Globals.Constants.Events.PubSub">
            <summary>
            Publish/Subscribe constants
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Globals.Constants.Events.PubSub.Subscribe">
            <summary>
            The topic for creating a subscription
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Globals.Constants.Events.PubSub.Unsubscribe">
            <summary>
            The topic for removing a subscription
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Globals.Constants.Events.Controller">
            <summary>
            Constants for events on controller lever
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Globals.Constants.Events.Controller.Opened">
            <summary>
            Topic for controller opened
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Globals.Constants.Events.Controller.Closed">
            <summary>
            Topic for controller closed
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Globals.Constants.Events.Controller.Init">
            <summary>
            Topic for controller initialized
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Globals.Constants.Events.Storage">
            <summary>
            Constants for storage commands
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Globals.Constants.Events.Storage.Set">
            <summary>
            Topic for saving to the storage
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Globals.Constants.Events.Storage.Get">
            <summary>
            Topic for reading from the storage
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Globals.Constants.Events.Storage.Clear">
            <summary>
            Topic for deleting total storage
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Globals.Constants.Events.Storage.Remove">
            <summary>
            Topic for deleting from the storage
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Globals.Constants.WebSocketFields">
            <summary>
            Constants for websockets handshake
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Globals.Constants.WebSocketFields.SecWebsocketKey">
            <summary>
            For reading the websocket key from the headers
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Globals.Constants.WebSocketFields.SecWebsocketProtocol">
            <summary>
            For building host response
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Globals.Constants.WebSocketFields.Origin">
            <summary>
            For getting origin from the headers and validating origins
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Globals.Constants.WebSocketFields.Host">
            <summary>
            For validating origins
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Interceptor.IConnectionInterceptor">
            <summary>
            Describes modules for creating connection interceptors.
            Every class that implements this interface will be treated as a connection interceptor
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Interceptor.IConnectionInterceptor.Connected(XSockets.Core.Common.Protocol.IXSocketProtocol)">
            <summary>
            Will be called when a client connects
            </summary>
            <param name="protocol">The protcol connected to</param>        
        </member>
        <member name="M:XSockets.Core.Common.Interceptor.IConnectionInterceptor.Disconnected(XSockets.Core.Common.Protocol.IXSocketProtocol)">
            <summary>
            Will be called when a client disconnects
            </summary>
            <param name="protocol"></param>        
        </member>
        <member name="M:XSockets.Core.Common.Interceptor.IConnectionInterceptor.HandshakeCompleted(XSockets.Core.Common.Protocol.IXSocketProtocol)">
            <summary>
            Will be called when the handshake is completed
            </summary>
            <param name="protocol"></param>
        </member>
        <member name="M:XSockets.Core.Common.Interceptor.IConnectionInterceptor.HandshakeInvalid(System.String)">
            <summary>
            Will be called when a handshake fails
            </summary>
            <param name="rawHandshake"></param>
        </member>
        <member name="T:XSockets.Core.Common.Interceptor.IErrorInterceptor">
            <summary>
            Describes modules for creating error interceptors.
            Every class that implements this interface will be treated as a error interceptor
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Interceptor.IErrorInterceptor.OnError(System.Exception)">
            <summary>
            Will be called whenever there is an exception caught inside of XSockets.        
            </summary>
            <param name="exception">The exception caught</param>
        </member>
        <member name="T:XSockets.Core.Common.Interceptor.IMessageInterceptor">
            <summary>
            Describes modules for creating message interceptors.
            Every class that implements this interface will be treated as a message interceptor
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Interceptor.IMessageInterceptor.OnIncomingMessage(XSockets.Core.Common.Protocol.IXSocketProtocol,XSockets.Core.Common.Socket.Event.Interface.IMessage)">
            <summary>
            Intercept message being sent to the server
            </summary>
            <param name="protocol">The protocol that the client sending is connected to</param>
            <param name="message">The message to receive</param>
        </member>
        <member name="M:XSockets.Core.Common.Interceptor.IMessageInterceptor.OnOutgoingMessage(XSockets.Core.Common.Protocol.IXSocketProtocol,XSockets.Core.Common.Socket.Event.Interface.IMessage)">
            <summary>
            Intercept message being sent from the server
            </summary>
            <param name="protocol">The protocol that client receiving is connected to</param>
            <param name="message">The message being sent out</param>
        </member>
        <member name="T:XSockets.Core.Common.Protocol.DeliveryType">
            <summary>
            To know if the message should be sent directly (RPC) or if we should check for subscriptions for each client (PUB/SUB)
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Protocol.DeliveryType.PubSub">
            <summary>
            Will only be sent to clients with subscriptions
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Protocol.DeliveryType.Rpc">
            <summary>
            Will be send to clients without subscriptions (still powerful with lambda expressions to target specific clients)
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Protocol.HeartbeatCloseReason">
            <summary>
            To tell the reason for a heartbeat failure
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Protocol.HeartbeatCloseReason.Timeout">
            <summary>
            The client did not respons within the given time frame
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Protocol.HeartbeatCloseReason.Invalid">
            <summary>
            The control data waas changed between ping and pong
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Protocol.IConnectionContext">
            <summary>
            Information about the connection
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Protocol.IConnectionContext.Environment">
            <summary>
            Environment (for example Owin information)
            but can be any pair of string,object that you want to set on the ConnectionContext
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Protocol.IConnectionContext.CookieCollection">
            <summary>
            Cookies from the connection
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Protocol.IConnectionContext.Headers">
            <summary>
            All headers of the connections
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Protocol.IConnectionContext.QueryString">
            <summary>
            The querystring of the connections
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Protocol.IConnectionContext.IsAuthenticated">
            <summary>
            Flag for knowing if the user is authenticated
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Protocol.IConnectionContext.IsSecureConnection">
            <summary>
            Flag for having a secure connection
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Protocol.IConnectionContext.Origin">
            <summary>
            The origin of the connection
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Protocol.IConnectionContext.RequestUri">
            <summary>
            Connection URI
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Protocol.IConnectionContext.SecWebSocketKey">
            <summary>
            Protocolinformation - The value of the SecWebSocketKey HTTP header included in the opening handshake.
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Protocol.IConnectionContext.SecWebSocketProtocols">
            <summary>
            
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Protocol.IConnectionContext.SecWebSocketVersion">
            <summary>
            
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Protocol.IConnectionContext.User">
            <summary>
            If authenticated this will hold the IPrincipal
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Protocol.IConnectionContext.Reconnecting">
            <summary>
            Flag for knowing if this client is reconnecting
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Protocol.IConnectionContext.PersistentId">
            <summary>
            The id for the connection
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Protocol.IProtocolProxy">
            <summary>
            Responsible for converting data flowing in/out of the server.
            Every protocol may have a unique message format, 
            this interface will help to convert incoming data into 
            IMessage and outgoing data back from IMessage to the protocol format
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Protocol.IProtocolProxy.In(System.Collections.Generic.IEnumerable{System.Byte},XSockets.Core.Common.Socket.Event.Arguments.MessageType)">
            <summary>
            Map the incoming data into a IMessage
            </summary>
            <param name="payload"></param>
            <param name="messageType"></param>
            <returns></returns>
        </member>
        <member name="M:XSockets.Core.Common.Protocol.IProtocolProxy.Out(XSockets.Core.Common.Socket.Event.Interface.IMessage)">
            <summary>
            Map the IMesage to the expected format for the protocol
            </summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="T:XSockets.Core.Common.Protocol.MessageDirection">
            <summary>
            Direction of a message
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Protocol.MessageDirection.In">
            <summary>
            Coming into the server
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Protocol.MessageDirection.Out">
            <summary>
            Going out from the server
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Protocol.IXSocketInternalProtocol">
            <summary>
            Internal XSockets protocol
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Protocol.IXSocketProtocol">
            <summary>
            Describes a basic protocol within XSockets
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Protocol.IXSocketProtocol.CanDoHeartbeat">
            <summary>
            Flag for knowing if the protocol can do automatic heartbeats (ping/pong)
            </summary>
            <returns></returns>
        </member>
        <member name="M:XSockets.Core.Common.Protocol.IXSocketProtocol.Available">
            <summary>
            Flag for knowing if communication is available
            </summary>
            <returns></returns>
        </member>
        <member name="M:XSockets.Core.Common.Protocol.IXSocketProtocol.SetUri">
            <summary>
            Sets the URI for the current connection
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Protocol.IXSocketProtocol.SetHeaders">
            <summary>
            Sets the headers for the current connection
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Protocol.IXSocketProtocol.SetQueryString">
            <summary>
            Sets the querystring for the current connection
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Protocol.IXSocketProtocol.Heartbeat(System.Int64,System.Action{XSockets.Core.Common.Protocol.HeartbeatCloseReason})">
            <summary>
            Will do a heartbeat to ensure that the client is connected, 
            when there is no response client will be closed and Action will be called (if not null)
            </summary>
            <param name="millisecondsInterval"></param>
            <param name="notifyAction"></param>
        </member>
        <member name="M:XSockets.Core.Common.Protocol.IXSocketProtocol.DoHandshake">
            <summary>
            Performs the handshake
            </summary>
            <returns>Returns true for valid, and false for invalid</returns>
        </member>
        <member name="M:XSockets.Core.Common.Protocol.IXSocketProtocol.Match(System.Collections.Generic.IList{System.Byte})">
            <summary>
            To identify what protocol to use.
            </summary>
            <param name="handshake"></param>
            <returns></returns>
        </member>
        <member name="M:XSockets.Core.Common.Protocol.IXSocketProtocol.Resolve(System.Collections.Generic.IEnumerable{System.Byte},XSockets.Core.Common.Socket.ISocketWrapper)">
            <summary>
            Will create a new instance of the specific protocol and parse out information passed in the initial handshake
            </summary>
            <param name="handshake"></param>
            <param name="socketWrapper"></param>
            <returns></returns>
        </member>
        <member name="M:XSockets.Core.Common.Protocol.IXSocketProtocol.Validate">
            <summary>
            Is called from the DoHandshake and performs Origin control etc
            </summary>
            <returns>Return true if valid, and false for invalid</returns>
        </member>
        <member name="M:XSockets.Core.Common.Protocol.IXSocketProtocol.GetHostResponse">
            <summary>
            If a handshake was valid this will return the protocol reponse in byte[]
            </summary>
            <returns>The handshake response in byte[]</returns>
        </member>
        <member name="M:XSockets.Core.Common.Protocol.IXSocketProtocol.Send(System.Byte[],System.AsyncCallback)">
            <summary>
            Sends data on the socket, used internally by XSockets.        
            </summary>
            <param name="data"></param>
            <param name="callback"></param>
        </member>
        <member name="M:XSockets.Core.Common.Protocol.IXSocketProtocol.Receive">
            <summary>
            Receives data on the socket, used internally by XSockets
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Protocol.IXSocketProtocol.Opened">
            <summary>
            Will be called after handshake and authentication pipeline
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Protocol.IXSocketProtocol.Disconnect(System.Boolean)">
            <summary>
            Closes the socket and the controllers used on this connection. 
            </summary>
            <param name="communicate">if false is passed in there will be no coomunication over the socket</param>
        </member>
        <member name="M:XSockets.Core.Common.Protocol.IXSocketProtocol.Read">
            <summary>
            Read another chunk of data from the socket into the buffer
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Protocol.IXSocketProtocol.NewInstance">
            <summary>
            Get a new instance of the protocol
            </summary>
            <returns></returns>
        </member>
        <member name="M:XSockets.Core.Common.Protocol.IXSocketProtocol.Create(System.Action{System.Collections.Generic.IEnumerable{System.Byte},XSockets.Core.Common.Protocol.FrameType})">
            <summary>
            Setup the method for frame handling
            </summary>
            <param name="onCompleted"></param>
            <returns></returns>
        </member>
        <member name="M:XSockets.Core.Common.Protocol.IXSocketProtocol.ReceiveData(System.ArraySegment{System.Byte},XSockets.Core.Common.Protocol.IReadState,System.Action{XSockets.Core.Common.Protocol.FrameType,System.Collections.Generic.IEnumerable{System.Byte}})">
            <summary>
            Process the chunk that was read from the socket
            </summary>
            <param name="data"></param>
            <param name="readState"></param>
            <param name="processFrame"></param>
        </member>
        <member name="M:XSockets.Core.Common.Protocol.IXSocketProtocol.ProcessFrame(XSockets.Core.Common.Protocol.FrameType,System.Collections.Generic.IEnumerable{System.Byte},System.Action{System.Collections.Generic.IEnumerable{System.Byte},XSockets.Core.Common.Protocol.FrameType})">
            <summary>
            Process a complete frame
            </summary>
            <param name="frameType"></param>
            <param name="data"></param>
            <param name="competed"></param>
        </member>
        <member name="M:XSockets.Core.Common.Protocol.IXSocketProtocol.Receive(System.Byte[],System.Action{System.Int32},System.Action{System.Exception},System.Int32)">
            <summary>
            The actual read from the socket
            </summary>
            <param name="buffer"></param>
            <param name="callback"></param>
            <param name="error"></param>
            <param name="offset"></param>
        </member>
        <member name="M:XSockets.Core.Common.Protocol.IXSocketProtocol.Send(System.Byte[],System.Action,System.Action{System.Exception})">
            <summary>
            Send data to the client
            </summary>
            <param name="buffer"></param>
            <param name="callback"></param>
            <param name="error"></param>
        </member>
        <member name="M:XSockets.Core.Common.Protocol.IXSocketProtocol.Close(System.Int32,System.Action,System.Action{System.Exception})">
            <summary>
            Close the connection
            </summary>
            <param name="reason"></param>
            <param name="callback"></param>
            <param name="error"></param>
        </member>
        <member name="M:XSockets.Core.Common.Protocol.IXSocketProtocol.Ping(System.Byte[])">
            <summary>
            Send a ping control frame
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:XSockets.Core.Common.Protocol.IXSocketProtocol.Pong(System.Byte[])">
            <summary>
            Send a pong control frame
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:XSockets.Core.Common.Protocol.IXSocketProtocol.OnIncomingFrame(System.Collections.Generic.IEnumerable{System.Byte},XSockets.Core.Common.Socket.Event.Arguments.MessageType)">
            <summary>
            Makes sure that what ever comes into the server is converted into a IMessage
            </summary>
            <param name="payload"></param>
            <param name="messageType"></param>
            <returns></returns>
        </member>
        <member name="M:XSockets.Core.Common.Protocol.IXSocketProtocol.OnOutgoingFrame(XSockets.Core.Common.Socket.Event.Interface.IMessage)">
            <summary>
            Converts the IMessage going out into what ever the protocol implemented wants
            </summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:XSockets.Core.Common.Protocol.IXSocketProtocol.InvokeMessageInterceptors(XSockets.Core.Common.Protocol.MessageDirection,XSockets.Core.Common.Socket.Event.Interface.IMessage)">
            <summary>
            Pass the message to all message interceptors (if any)
            </summary>
            <param name="direction"></param>
            <param name="message"></param>
        </member>
        <member name="M:XSockets.Core.Common.Protocol.IXSocketProtocol.InvokeErrorInterceptors(System.Exception)">
            <summary>
            Pass the exception to all error interceptors (if any)
            </summary>
            <param name="ex"></param>
        </member>
        <member name="M:XSockets.Core.Common.Protocol.IXSocketProtocol.FatalError(System.Exception)">
            <summary>
            Will send error data to the client and then close the connection
            </summary>       
            <param name="e"></param>
        </member>
        <member name="E:XSockets.Core.Common.Protocol.IXSocketProtocol.OnPong">
            <summary>
            Fires when a pong is received
            </summary>
        </member>
        <member name="E:XSockets.Core.Common.Protocol.IXSocketProtocol.OnPing">
            <summary>
            Fires when a ping is received
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Protocol.IXSocketProtocol.LastComTime">
            <summary>
            To be able to only ping if needed
            Will be updated when the soacket reads incoming data
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Protocol.IXSocketProtocol.InterceptorsOn">
            <summary>
            Flag for knowing if interceptors is enabled or not
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Protocol.IXSocketProtocol.ConnectionContext">
            <summary>
            Information about the current connection
            Headers, Cookies, UserInfomation etc
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Protocol.IXSocketProtocol.ConfigurationSetting">
            <summary>
            The configuration for this server
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Protocol.IXSocketProtocol.XSocketPipeline">
            <summary>
            The pipeline that will receive data from the protocol, and also will send back data to the protocol
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Protocol.IXSocketProtocol.JsonSerializer">
            <summary>
            The JSON serializer for this connection
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Protocol.IXSocketProtocol.ProtocolProxy">
            <summary>
            Handle formatting for incoming/outgoing data
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Protocol.IXSocketProtocol.ScaleOut">
            <summary>
            The ScaleOut plugin
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Protocol.IXSocketProtocol.Controllers">
            <summary>
            The controllers currently used in this connection
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Protocol.IXSocketProtocol.DefaultController">
            <summary>
            The default controller of this connection
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Protocol.IXSocketProtocol.BufferSize">
            <summary>
            Buffersize for the protcol
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Protocol.IXSocketProtocol.Socket">
            <summary>
            Wrapper for socket communication
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Protocol.IXSocketProtocol.ProtocolIdentifier">
            <summary>
            A friendly name for the protocol
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Protocol.IXSocketProtocol.HostResponse">
            <summary>
            The response that will be sent to the client when a handshake was completed
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Protocol.IXSocketProtocol.AllowedOrigins">
            <summary>
            Origins allowed, comes from the configuration settings
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Protocol.IXSocketProtocol.RawHandshake">
            <summary>
            The raw hadnshake sent from the client
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Protocol.IXSocketProtocol.Handshake">
            <summary>
            The initial handshake sent from the client
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Protocol.IXSocketProtocol.Response">
            <summary>
            The response that will be sent back after a valid handshake
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Protocol.IXWebSocketProtocol">
            <summary>
            The base-protocol for WebSockets
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Protocol.Rfc6455CloseReason">
            <summary>
            See http://tools.ietf.org/html/rfc6455#page-43
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Protocol.Rfc6455CloseReason.NormalClosure">
            <summary>
            1000 indicates a normal closure, meaning that the purpose for
            which the connection was established has been fulfilled.
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Protocol.Rfc6455CloseReason.GoingAway">
            <summary>
            1001 indicates that an endpoint is "going away", such as a server
            going down or a browser having navigated away from a page.
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Protocol.Rfc6455CloseReason.ProtocolError">
            <summary>
            1002 indicates that an endpoint is terminating the connection due 
            to a protocol error.
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Protocol.Rfc6455CloseReason.UnsupportedDataType">
            <summary>
            1003 indicates that an endpoint is terminating the connection
            because it has received a type of data it cannot accept (e.g., an
            endpoint that understands only text data MAY send this if it
            receives a binary message).
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Protocol.Rfc6455CloseReason.NoStatusReceived">
            <summary>
            1005 is a reserved value and MUST NOT be set as a status code in a
            Close control frame by an endpoint.  It is designated for use in
            applications expecting a status code to indicate that no status
            code was actually present.
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Protocol.Rfc6455CloseReason.AbnormalClosure">
            <summary>
            1006 is a reserved value and MUST NOT be set as a status code in a
            Close control frame by an endpoint.  It is designated for use in
            applications expecting a status code to indicate that the
            connection was closed abnormally, e.g., without sending or
            receiving a Close control frame.
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Protocol.Rfc6455CloseReason.InvalidFramePayloadData">
            <summary>
            1007 indicates that an endpoint is terminating the connection
            because it has received data within a message that was not
            consistent with the type of the message (e.g., non-UTF-8 [RFC3629]
            data within a text message).
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Protocol.Rfc6455CloseReason.PolicyViolation">
            <summary>
            1008 indicates that an endpoint is terminating the connection
            because it has received a message that violates its policy.  This
            is a generic status code that can be returned when there is no
            other more suitable status code (e.g., 1003 or 1009) or if there
            is a need to hide specific details about the policy.
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Protocol.Rfc6455CloseReason.MessageTooBig">
            <summary>
            1009 indicates that an endpoint is terminating the connection
            because it has received a message that is too big for it to
            process.
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Protocol.Rfc6455CloseReason.MandatoryExt">
            <summary>
            1010 indicates that an endpoint (client) is terminating the
            connection because it has expected the server to negotiate one or
            more extension, but the server didn't return them in the response
            message of the WebSocket handshake.  The list of extensions that
            are needed SHOULD appear in the /reason/ part of the Close frame.
            Note that this status code is not used by the server, because it
            can fail the WebSocket handshake instead.
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Protocol.Rfc6455CloseReason.InternalServerError">
            <summary>
            1011 indicates that a server is terminating the connection because
            it encountered an unexpected condition that prevented it from
            fulfilling the request.
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Protocol.Rfc6455CloseReason.TlsHandshake">
            <summary>
            1015 is a reserved value and MUST NOT be set as a status code in a
            Close control frame by an endpoint.  It is designated for use in
            applications expecting a status code to indicate that the
            connection was closed due to a failure to perform a TLS handshake
            (e.g., the server certificate can't be verified).
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Protocol.Rfc6455CloseReason.ApplicationError">
            <summary>
            Status codes in the range 3000-3999 are reserved for use by
            libraries, frameworks, and applications.  These status codes are
            registered directly with IANA.  The interpretation of these codes
            is undefined by this protocol.
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Protocol.Rfc6455CloseReason.ValidCloseCodes">
            <summary>
            All codes as an array of integers
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Protocol.FrameType">
            <summary>
            Operation codes as described in http://tools.ietf.org/html/rfc6455
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Protocol.FrameType.Continuation">
            <summary>
            Denotes a continuation frame
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Protocol.FrameType.Text">
            <summary>
            Denotes a text frame
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Protocol.FrameType.Binary">
            <summary>
            Denotes a binary frame
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Protocol.FrameType.Close">
            <summary>
            Denotes a connection close
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Protocol.FrameType.Ping">
            <summary>
            Denotes a ping
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Protocol.FrameType.Pong">
            <summary>
            Denotes a pong
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Protocol.IXFrameHandler">
            <summary>
            Receives/read frame-data
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Protocol.IXFrameHandler.Receive(System.ArraySegment{System.Byte})">
            <summary>
            
            </summary>
            <param name="data"></param>
        </member>
        <member name="T:XSockets.Core.Common.Protocol.IRfc6455Protocol">
            <summary>
            The RFC6455 protocol
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Protocol.IReadState">
            <summary>
            Readstate object
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Protocol.IReadState.Clear">
            <summary>
            Clear the reader
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Protocol.IReadState.Data">
            <summary>
            Data reading
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Protocol.IReadState.FrameType">
            <summary>
            Type of frame
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Protocol.IReadState.FrameBytes">
            <summary>
            Reading continous frames etc
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Protocol.IReadState.IsFinal">
            <summary>
            Flag for final
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Protocol.IReadState.Length">
            <summary>
            Size to read
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Protocol.IReadState.BufferedIndex">
            <summary>
            
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Security.IAuthorizationModule">
            <summary>
            The default plugin for handling authorizaiton on controller/method level    
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Security.IAuthorizationModule.IsAuthorized(XSockets.Core.Common.Socket.IXSocketController,XSockets.Core.Common.Socket.Attributes.IAuthorizeAttribute)">
            <summary>
            Checks if the current user can access this controller/method
            </summary>
            <param name="controller"></param>
            <param name="authorizeAttribute"></param>
            <returns></returns>
        </member>
        <member name="T:XSockets.Core.Common.Socket.Attributes.AllowAnonymousAttribute">
            <summary>
            Attribute used for allowing anonymous access to controllers and controller-methods
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Socket.Attributes.AuthorizeAttribute">
            <summary>
            Attribute used for authorization on controllers and controller-methods
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Socket.Attributes.IAuthorizeAttribute">
            <summary>
            Attribute used for authorization on controllers and controller-methods
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.Attributes.IAuthorizeAttribute.Roles">
            <summary>
            Roles that is allowed, separate by comma
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.Attributes.IAuthorizeAttribute.Users">
            <summary>
            Users that is allowed, separate by comma
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Socket.Attributes.AuthorizeAttribute.#ctor">
            <summary>
            Ctor
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Socket.Attributes.AuthorizeAttribute.#ctor(System.String,System.String)">
            <summary>
            Ctor
            </summary>
            <param name="roles">Roles allowed</param>
            <param name="users">Users allowed</param>
        </member>
        <member name="P:XSockets.Core.Common.Socket.Attributes.AuthorizeAttribute.Roles">
            <summary>
            Roles allowed, separate by comma
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.Attributes.AuthorizeAttribute.Users">
            <summary>
            Users allowed, separate by comma
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Socket.Attributes.IRequireSslAttribute">
            <summary>
            Will require TLS/SSL on controllers/methods 
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Socket.Attributes.RequireSslAttribute">
            <summary>
            Will require TLS/SSL on controllers/methods 
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Socket.Event.Arguments.ControlArgs">
            <summary>
            For sending/receiving pings/pongs
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Socket.Event.Interface.IControlArgs">
            <summary>
            For sending/receiving pings/pongs
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.Event.Interface.IControlArgs.FrameType">
            <summary>
            A ping or a pong
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.Event.Interface.IControlArgs.Data">
            <summary>
            Data that ride along to be able to validate pings/pongs
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Socket.Event.Arguments.ControlArgs.#ctor(XSockets.Core.Common.Protocol.FrameType,System.Byte[])">
            <summary>
            Ctor
            </summary>
            <param name="frameType">A ping or pong</param>
            <param name="data">Data that ride along to be able to validate pings/pongs</param>
        </member>
        <member name="P:XSockets.Core.Common.Socket.Event.Arguments.ControlArgs.FrameType">
            <summary>
            A ping or a pong
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.Event.Arguments.ControlArgs.Data">
            <summary>
            Data for verifying the ping/pong
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Socket.Event.Arguments.MessageType">
            <summary>
            To know what type the IMessage contains, text or binary
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Socket.Event.Arguments.MessageType.Text">
            <summary>
            The message is text-based
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Socket.Event.Arguments.MessageType.Binary">
            <summary>
            The message is binary-based
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Socket.Event.Arguments.OnAuthorizationFailedArgs">
            <summary>
            Event argument that will be passed when a call fails due to invalid authorization
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Socket.Event.Arguments.OnAuthorizationFailedArgs.#ctor(XSockets.Core.Common.Socket.IXSocketController,System.String)">
            <summary>
            Ctor
            </summary>
            <param name="controller">The invoked controller</param>
            <param name="methodName">The name of the invoked method</param>
        </member>
        <member name="P:XSockets.Core.Common.Socket.Event.Arguments.OnAuthorizationFailedArgs.Controller">
            <summary>
            The invoked controller
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.Event.Arguments.OnAuthorizationFailedArgs.MethodName">
            <summary>
            The name of the invoked method
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Socket.Event.Arguments.OnClientConnectArgs">
            <summary>
            Event argument that will be passed when a client connects to a controller
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Socket.Event.Arguments.OnClientConnectArgs.#ctor(XSockets.Core.Common.Socket.IXSocketController)">
            <summary>
            Ctor
            </summary>
            <param name="controller">The controller that the client connected to</param>
        </member>
        <member name="P:XSockets.Core.Common.Socket.Event.Arguments.OnClientConnectArgs.Controller">
            <summary>
            The controller that the client connected to
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Socket.Event.Arguments.OnClientDisconnectArgs">
            <summary>
            Event argument that will be passed when a client disconnects from a controller
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Socket.Event.Arguments.OnClientDisconnectArgs.#ctor(XSockets.Core.Common.Socket.IXSocketController)">
            <summary>
            Ctor
            </summary>
            <param name="controller">The controller that was disconnected</param>
        </member>
        <member name="P:XSockets.Core.Common.Socket.Event.Arguments.OnClientDisconnectArgs.Controller">
            <summary>
            The controller that was disconnected
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Socket.Event.Arguments.OnErrorArgs">
            <summary>
            Event argument for a errors
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Socket.Event.Arguments.OnErrorArgs.#ctor(System.String)">
            <summary>
            Ctor
            </summary>
            <param name="message">Describe the exception</param>
        </member>
        <member name="M:XSockets.Core.Common.Socket.Event.Arguments.OnErrorArgs.#ctor(System.Exception)">
            <summary>
            Ctor
            </summary>
            <param name="ex">The exception caught or thrown</param>
        </member>
        <member name="M:XSockets.Core.Common.Socket.Event.Arguments.OnErrorArgs.#ctor(System.Exception,System.String)">
            <summary>
            Ctor
            </summary>
            <param name="innerException">The exception caught or thrown</param>
            <param name="message">Describe the exception</param>
        </member>
        <member name="P:XSockets.Core.Common.Socket.Event.Arguments.OnErrorArgs.Exception">
            <summary>
            The internally created exception that is based on the exception/message passed in
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Socket.Event.Arguments.OnHandshakeCompleteArgs">
            <summary>
            Event argument for a valid handshake event
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Socket.Event.Arguments.OnHandshakeCompleteArgs.#ctor(XSockets.Core.Common.Protocol.IXSocketProtocol,System.String)">
            <summary>
            Ctor
            </summary>
            <param name="protocol">The protocol that the client connected to</param>
            <param name="handshake">The raw handshake sent from the client</param>
        </member>
        <member name="P:XSockets.Core.Common.Socket.Event.Arguments.OnHandshakeCompleteArgs.Protocol">
            <summary>
            The protocol that the client connected to
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.Event.Arguments.OnHandshakeCompleteArgs.Handshake">
            <summary>
            The raw handshake sent from the client
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Socket.Event.Arguments.OnHandshakeInvalidArgs">
            <summary>
            Event argument for a invalid handshake event
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Socket.Event.Arguments.OnHandshakeInvalidArgs.#ctor(XSockets.Core.Common.Protocol.IXSocketProtocol,System.String)">
            <summary>
            Ctor
            </summary>
            <param name="protocol">The protocol that the client tried to connect to</param>
            <param name="handshake">The raw handshake sent from the client</param>
        </member>
        <member name="P:XSockets.Core.Common.Socket.Event.Arguments.OnHandshakeInvalidArgs.Protocol">
            <summary>
            The protcol that the client tried to connect to
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.Event.Arguments.OnHandshakeInvalidArgs.Handshake">
            <summary>
            The raw handshake sent from the client
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Socket.Event.Arguments.OnRegisteredPluginArgs">
            <summary>
            EventArgs for the event that will be called when a controller is registered
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Socket.Event.Arguments.OnRegisteredPluginArgs.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="message"></param>
        </member>
        <member name="P:XSockets.Core.Common.Socket.Event.Arguments.OnRegisteredPluginArgs.Message">
            <summary>
            The information about the controler registration
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Socket.Event.Arguments.OnRegisteredProtocolArgs">
            <summary>
            EventArgs for the event that will be called when a protcol is registered
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Socket.Event.Arguments.OnRegisteredProtocolArgs.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="message"></param>
        </member>
        <member name="P:XSockets.Core.Common.Socket.Event.Arguments.OnRegisteredProtocolArgs.Message">
            <summary>
            The information about the protocol registration
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Socket.Event.Attributes.ControllerEventAttribute">
            <summary>
            Attribute to set on methods on your plugins to implement custom handling to event aliases.
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Socket.Event.Attributes.ControllerEventAttribute.#ctor(System.String,System.Int32)">
            <summary>
            Ctor for the attribute
            </summary>
            <param name="alias">The alias to set for the method</param>
            <param name="order">[optional] the order that the method will be invoked in</param>
        </member>
        <member name="P:XSockets.Core.Common.Socket.Event.Attributes.ControllerEventAttribute.Alias">
            <summary>
            The alias that will be used to call the method the attribute is attached to.
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.Event.Attributes.ControllerEventAttribute.Order">
            <summary>
            If there are several method with the same alias this decides the order to invoke them in.
            Lowest will be called first.
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.Event.Attributes.ControllerEventAttribute.Synchron">
            <summary>
            Flag to make the call asynchron or synchron.
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Socket.Event.Attributes.NoEventAttribute">
            <summary>
            Use on methods and properties that you do not want to expose to clients
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Socket.Event.Interface.IPluginCustomEventInfo">
            <summary>
            Information about a actionmethod on a controller
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.Event.Interface.IPluginCustomEventInfo.MethodInfo">
            <summary>
            Method information for the method
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.Event.Interface.IPluginCustomEventInfo.ParameterInfo">
            <summary>
            Information about parameters on the method
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.Event.Interface.IPluginCustomEventInfo.Order">
            <summary>
            Knowing in what order to call if there are several methods to invoke
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.Event.Interface.IPluginCustomEventInfo.Synchron">
            <summary>
            Should the call be async or sync
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.Event.Interface.IPluginCustomEventInfo.Authorize">
            <summary>
            Is authorization needed
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.Event.Interface.IPluginCustomEventInfo.RequireSsl">
            <summary>
            Is SSL/TLS needed
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.Event.Interface.IPluginCustomEventInfo.ReturnsTask">
            <summary>
            Flag for knowing if the action method returns a task to avoid reflection in call
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.Event.Interface.IPluginCustomEventInfo.AuthorizeAttribute">
            <summary>
            Authorize information
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Socket.Event.Interface.IMessage">
            <summary>
            The internal message model of XSockets.
            All data going in/out of XSockets will be in this form.
            The model can handle both text and binary data.
            </summary>    
        </member>
        <member name="M:XSockets.Core.Common.Socket.Event.Interface.IMessage.Extract``1">
            <summary>
            Method that can extract strongly typed object from the message.
            If it is a text message the deserialization will be from the Data property.
            if it is binary the deserialization will be from the blob since you can attach meta data about files etc
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:XSockets.Core.Common.Socket.Event.Interface.IMessage.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:XSockets.Core.Common.Socket.Event.Interface.IMessage.ToBytes">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:XSockets.Core.Common.Socket.Event.Interface.IMessage.Blob">
            <summary>
            The binary data attached to the message
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.Event.Interface.IMessage.Data">
            <summary>
            The JSON passed in
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.Event.Interface.IMessage.MessageType">
            <summary>
            To know if it is Binary or Text
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.Event.Interface.IMessage.Controller">
            <summary>
            The controller the should be communicated with
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.Event.Interface.IMessage.Topic">
            <summary>
            The topic (method) to target on the contorller
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Socket.IClientInfo">
            <summary>
            Information about a connection
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.IClientInfo.ConnectionId">
            <summary>
            The unique id for the connection to a controller
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.IClientInfo.PersistentId">
            <summary>
            The id for the protocol connection
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.IClientInfo.Controller">
            <summary>
            The controller connected to
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Socket.IControllerWrapper">
            <summary>
            Wraps a controller by type
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.IControllerWrapper.Controller">
            <summary>
            The XSockets controller
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.IControllerWrapper.Type">
            <summary>
            The underlying type of the controller
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Socket.IProtocolHandshakeHandler">
            <summary>
            Handles the handshake when a client connects
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Socket.IProtocolHandshakeHandler.Init(XSockets.Core.Common.Socket.ISocketWrapper)">
            <summary>
            Do handsahke with the connecting socket
            </summary>
            <param name="socket">The socket to send the handshake to</param>
        </member>
        <member name="M:XSockets.Core.Common.Socket.IProtocolHandshakeHandler.HandShake(System.Collections.Generic.IList{System.Byte})">
            <summary>
            
            </summary>
            <param name="ar"></param>
        </member>
        <member name="M:XSockets.Core.Common.Socket.IProtocolHandshakeHandler.GetProtocolFromHandshake(System.Collections.Generic.IList{System.Byte})">
            <summary>
            Finds the first protocol that matches the handshake.
            By default the Match method on the <see cref="T:XSockets.Core.Common.Protocol.IXSocketProtocol"/> decide if the protocol matches
            </summary>
            <param name="handshake"></param>
            <returns></returns>
        </member>
        <member name="P:XSockets.Core.Common.Socket.IProtocolHandshakeHandler.XSocketProtocolFactory">
            <summary>
            Handles protocol instances/creation
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.IProtocolHandshakeHandler.Socket">
            <summary>
            Socket connecting
            </summary>
        </member>
        <member name="E:XSockets.Core.Common.Socket.IProtocolHandshakeHandler.OnHandshakeComplete">
            <summary>
            Fires when a handshake is completed and ok
            </summary>
        </member>
        <member name="E:XSockets.Core.Common.Socket.IProtocolHandshakeHandler.OnHandshakeInvalid">
            <summary>
            Fires if the handshake was bad, connection rejected
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Socket.ISocketWrapper">
            <summary>
            Wrapper class for socket communication
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Socket.ISocketWrapper.Accept(System.Action{XSockets.Core.Common.Socket.ISocketWrapper},System.Action{System.Exception})">
            <summary>
            Handles incomming connections
            </summary>
            <param name="callback"></param>
            <param name="error"></param>
            <returns></returns>
        </member>
        <member name="M:XSockets.Core.Common.Socket.ISocketWrapper.Send(System.Byte[],System.Action,System.Action{System.Exception})">
            <summary>
            Sends data to the client
            </summary>
            <param name="buffer">Data to send</param>
            <param name="callback">Action after sending data</param>
            <param name="error">Action to call if there is exceptions</param>
            <returns></returns>
        </member>
        <member name="M:XSockets.Core.Common.Socket.ISocketWrapper.Receive(System.Byte[],System.Action{System.Int32},System.Action{System.Exception},System.Int32)">
            <summary>
            Receives data from the client
            </summary>
            <param name="buffer">Buffer that will be filled with data</param>
            <param name="callback">Action to run when receive is completed</param>
            <param name="error">Action to call if there is exception</param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:XSockets.Core.Common.Socket.ISocketWrapper.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate2,System.Boolean,System.Action,System.Action{System.Exception})">
            <summary>
            
            </summary>
            <param name="certificate"></param>
            <param name="forceClientCertificate"></param>
            <param name="callback"></param>
            <param name="error"></param>
            <returns></returns>
        </member>
        <member name="M:XSockets.Core.Common.Socket.ISocketWrapper.Close">
            <summary>
            
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Socket.ISocketWrapper.Bind(System.Net.EndPoint)">
            <summary>
            
            </summary>
            <param name="ipLocal"></param>
        </member>
        <member name="M:XSockets.Core.Common.Socket.ISocketWrapper.Listen(System.Int32)">
            <summary>
            
            </summary>
            <param name="backlog"></param>
        </member>
        <member name="P:XSockets.Core.Common.Socket.ISocketWrapper.Connected">
            <summary>
            Flag for knowing connection state
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.ISocketWrapper.RemoteIpAddress">
            <summary>
            The clients IP
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.ISocketWrapper.Stream">
            <summary>
            Communication stream
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.ISocketWrapper.RemoteCertificate">
            <summary>
            An X509Certificate object that represents the certificate supplied for authentication or null if no certificate was supplied.
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.ISocketWrapper.DataAvailable">
            <summary>
            To know if there are any more data to read on the stream
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.ISocketWrapper.Socket">
            <summary>
            The communication socket
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Socket.IXSocketAuthenticationPipeline">
            <summary>
            Authentication plugin. XSockets provides a default plugin, but you can implement your own
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Socket.IXSocketAuthenticationPipeline.GetPrincipal(XSockets.Core.Common.Protocol.IXSocketProtocol)">
            <summary>
            Will be called after the handshake is completed. 
            Returns the IPrincipal extracted inside the method
            </summary>
            <param name="protocol">The communication protocol that the client connected to</param>
            <returns>A principal object</returns>
        </member>
        <member name="T:XSockets.Core.Common.Socket.IXSocketServerContainer">
            <summary>
            Singleton that handle all plugins and starts servers
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Socket.IXSocketServerContainer.Start(System.Boolean,System.Boolean,System.Collections.Generic.IList{XSockets.Core.Common.Configuration.IConfigurationSetting})">
            <summary>
            Starts the server(s)
            </summary>
            <param name="useLoopback">Automatically setup a configuration for the loopback adress</param>
            <param name="withInterceptors">True by default, False will disable all interceptors</param>
            <param name="configurationSettings">Pass in manual configuration (optional)</param>
        </member>
        <member name="M:XSockets.Core.Common.Socket.IXSocketServerContainer.Stop">
            <summary>
            Kill all server instances
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.IXSocketServerContainer.XSocketProtocolFactory">
            <summary>
            Handles protocol instances/creation
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.IXSocketServerContainer.XSocketFactory">
            <summary>
            Handles controller instances/creation
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.IXSocketServerContainer.XSocketPlugins">
            <summary>
            Loaded controllers
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.IXSocketServerContainer.XSocketProtocolPlugins">
            <summary>
            Communication protocols loaded
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.IXSocketServerContainer.ConfigurationSettings">
            <summary>
            Configurations loaded
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.IXSocketServerContainer.WithInterceptors">
            <summary>
            Decides if interceptors will be used or not
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.IXSocketServerContainer.ServerStarted">
            <summary>
            Time for server start
            </summary>
        </member>
        <member name="E:XSockets.Core.Common.Socket.IXSocketServerContainer.OnRegisteredPlugin">
            <summary>
            Will fire when a plugin is added to the IXSocketFactory
            </summary>
        </member>
        <member name="E:XSockets.Core.Common.Socket.IXSocketServerContainer.OnRegisteredProtocol">
            <summary>
            Will fire when a protocol is added to the IXSocketProtocolFactory
            </summary>
        </member>
        <member name="E:XSockets.Core.Common.Socket.IXSocketServerContainer.OnStarted">
            <summary>
            Will fire when the container has started the server(s)
            </summary>
        </member>
        <member name="E:XSockets.Core.Common.Socket.IXSocketServerContainer.OnStopped">
            <summary>
            Will fire when the container stops the server(s)
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.IXSocketServerContainer.Servers">
            <summary>
            All the servers in the container
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Socket.IXSocketController">
            <summary>
            Basic knowledge and description about a controller
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Socket.IXSocketController.InvokeAuthorizationFailed(System.String)">
            <summary>
            Will be called when a unathorized call is made to a method with the Authorize attribute
            Will fire the OnAuthorizationFailed event
            </summary>
            <param name="methodName"></param>
        </member>
        <member name="M:XSockets.Core.Common.Socket.IXSocketController.HandleError(System.Exception)">
            <summary>
            Internally called when a exception is caught.
            Will fire the OnError event
            </summary>
            <param name="ex"></param>
        </member>
        <member name="M:XSockets.Core.Common.Socket.IXSocketController.OnMessage(XSockets.Core.Common.Socket.Event.Interface.IMessage)">
            <summary>
            Override this method to be able to handle messages that do not have a action method defined.
            If overriden this method will be called when no matching was found for the arriving message
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:XSockets.Core.Common.Socket.IXSocketController.OnAuthorization(XSockets.Core.Common.Socket.Attributes.IAuthorizeAttribute)">
            <summary>
            Override this to do custom authorization for a call to a method with the Authorize attribute
            </summary>
            <param name="authorizeAttribute">Information about the requirements for the called method (Roles and UserNames)</param>
            <returns>True if ok, otherwise false</returns>
        </member>
        <member name="M:XSockets.Core.Common.Socket.IXSocketController.Close(System.Boolean)">
            <summary>
            Clean up the use of the controller
            </summary>
            <param name="communicate">False will not try to use the socket for communication</param>
        </member>
        <member name="M:XSockets.Core.Common.Socket.IXSocketController.Open">
            <summary>
            Invoked internally
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Socket.IXSocketController.OnOpened">
            <summary>
            Will be called when the controller is opened
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Socket.IXSocketController.OnClosed">
            <summary>
            Will be called when the controller is closed
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Socket.IXSocketController.OnReopened">
            <summary>
            Will be called when the controller is reopened
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Socket.IXSocketController.OnAuthorizationFailure(System.String)">
            <summary>
            Will be called when a call to a method fails due to bad credentials
            </summary>
            <param name="methodName"></param>
        </member>
        <member name="M:XSockets.Core.Common.Socket.IXSocketController.Send(System.Byte[])">
            <summary>
            Send data over the socket.
            Do not use this method for sending data.
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:XSockets.Core.Common.Socket.IXSocketController.SubscribesTo(System.String)">
            <summary>
            Return true if the controller has a subscription to the topic passed in.
            </summary>
            <param name="topic">The subscription topic</param>
            <returns>True if there was a subscription, otherwise false</returns>
        </member>
        <member name="M:XSockets.Core.Common.Socket.IXSocketController.GetSubscribers``1(System.String)">
            <summary>
            Finds all the subscribers to 'topic' on a controller
            </summary>
            <typeparam name="T">Controller type</typeparam>
            <param name="topic">Name of the subscription</param>
            <returns>List of all subscribers</returns>
        </member>
        <member name="M:XSockets.Core.Common.Socket.IXSocketController.GetSubscribersReadOnly``1(System.String)">
            <summary>
            Gets a copy of the current subsribers as a readonly list
            </summary>
            <typeparam name="T"></typeparam>
            <param name="topic"></param>
            <returns></returns>
        </member>
        <member name="P:XSockets.Core.Common.Socket.IXSocketController.Alias">
            <summary>
            The name used to connect to this controller
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.IXSocketController.PluginRange">
            <summary>
            Public is default and a regular XSockets controller
            Internal cant be connected to and will be singletons        
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.IXSocketController.CorrectController">
            <summary>
            Flag that will be set to false internally if the client tries to connect to a non-existing controller
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.IXSocketController.CustomEvents">
            <summary>
            All methods defined for communication of the controller
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.IXSocketController.ProtocolInstance">
            <summary>
            The communication protocol that the client connected to
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.IXSocketController.ConnectionId">
            <summary>
            A unique id for this controller instance
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.IXSocketController.PersistentId">
            <summary>
            The id for this socket connection, also found on the Context property (IConnectionContext)
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.IXSocketController.ConnectionContext">
            <summary>
            Information about the connection.
            Cookies, Headers, Security, IPrincipal etc
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.IXSocketController.AuthorizeController">
            <summary>
            Flag set internally to know if communication need to be authorized
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.IXSocketController.AuthorizeOnMessage">
            <summary>
            Flag set internally to know if communication to "OnMessage" need to be authorized
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.IXSocketController.AuthorizeAttribute">
            <summary>
            
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.IXSocketController.RequireSsl">
            <summary>
            The controller requires SSL/TLS
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.IXSocketController.RequireSslOnMessage">
            <summary>
            Used internally when invoking OnMessage if overridden
            </summary>
        </member>
        <member name="E:XSockets.Core.Common.Socket.IXSocketController.OnOpen">
            <summary>
            Fires when the client communicates with the controller for the first time
            </summary>
        </member>
        <member name="E:XSockets.Core.Common.Socket.IXSocketController.OnReopen">
            <summary>
            Fires after OnOpen if the PersistenId was passed in with the connection.
            </summary>
        </member>
        <member name="E:XSockets.Core.Common.Socket.IXSocketController.OnClose">
            <summary>
            Fires when the connection is closed or if the client calls the Close method on the controller.
            </summary>
        </member>
        <member name="E:XSockets.Core.Common.Socket.IXSocketController.OnError">
            <summary>
            Fires if there an exception is caught, will also fire if you call "HandleError" and pass in the exception
            </summary>
        </member>
        <member name="E:XSockets.Core.Common.Socket.IXSocketController.OnAuthorizationFailed">
            <summary>
            Fires when a unauthorized call is made to a method with the Authorize attribute
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.IXSocketController.Subscriptions">
            <summary>
            All subscriptions for this controller
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Socket.IXSocketServer">
            <summary>
            A server instance that has its own endpoint for clients to connect to
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Socket.IXSocketServer.Start(XSockets.Core.Common.Configuration.IConfigurationSetting)">
            <summary>
            Starts the server with the specified configuration
            </summary>
            <param name="configurationSetting"></param>
        </member>
        <member name="M:XSockets.Core.Common.Socket.IXSocketServer.Stop">
            <summary>
            Stops the server
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.IXSocketServer.ConfigurationSetting">
            <summary>
            The configuration for this server instance
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.IXSocketServer.ListenerSocket">
            <summary>
            Socket for accepting connections
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.IXSocketServer.IsStarted">
            <summary>
            True if the server is started
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Socket.IXSocketServer.ServerId">
            <summary>
            A unique id for this server instance
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Socket.IXSocketPipeline">
            <summary>
            The message pipeline, XSockets provides a default pipeline but you can implement your own
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Socket.IXSocketPipeline.OnIncomingMessage(XSockets.Core.Common.Socket.IXSocketController,XSockets.Core.Common.Socket.Event.Interface.IMessage)">
            <summary>
            Receives messages from the protcol and let them continue into the server (to the IXSocketController)
            </summary>
            <param name="controller">The controller that the communication is targeting</param>
            <param name="e">The IMessage that contains topic and data to pass into the IXSocketController</param>
        </member>
        <member name="M:XSockets.Core.Common.Socket.IXSocketPipeline.OnOutgoingMessage(XSockets.Core.Common.Socket.IXSocketController,XSockets.Core.Common.Socket.Event.Interface.IMessage)">
            <summary>
            Receives data from a IXSocketController, the returned IMessage will continue to the protocol
            </summary>
            <param name="controller">The controller that is sending the message out</param>
            <param name="e">The IMessage that contains topic and data to send to the client(s)</param>
            <returns>The IMessage that will continue out of the server</returns>
        </member>
        <member name="T:XSockets.Core.Common.Socket.SubscriptionType">
            <summary>
            Described the binding/subscription when using publish/subscribe 
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Socket.SubscriptionType.All">
            <summary>
            The subscription will be active until unsubscribe is caled
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Socket.SubscriptionType.Many">
            <summary>
            The subscription will be active for n messages configurable when binding
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Socket.SubscriptionType.One">
            <summary>
            The subscription will only be active for one message
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Utility.Logging.IXLogger">
            <summary>
            The interface exposing all "log-types" needed
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Logging.IXLogger.SetEventLevel(XSockets.Core.Common.Utility.Logging.LogEventLevel)">
            <summary>
            
            </summary>
            <param name="level"></param>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Logging.IXLogger.Verbose(System.String,System.Object[])">
            <summary>
            
            </summary>
            <param name="template"></param>
            <param name="parmeters"></param>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Logging.IXLogger.Verbose(System.Exception,System.String,System.Object[])">
            <summary>
            
            </summary>
            <param name="ex"></param>
            <param name="template"></param>
            <param name="parmeters"></param>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Logging.IXLogger.Debug(System.String,System.Object[])">
            <summary>
            
            </summary>
            <param name="template"></param>
            <param name="parmeters"></param>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Logging.IXLogger.Debug(System.Exception,System.String,System.Object[])">
            <summary>
            
            </summary>
            <param name="ex"></param>
            <param name="template"></param>
            <param name="parmeters"></param>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Logging.IXLogger.Information(System.String,System.Object[])">
            <summary>
            
            </summary>
            <param name="template"></param>
            <param name="parmeters"></param>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Logging.IXLogger.Information(System.Exception,System.String,System.Object[])">
            <summary>
            
            </summary>
            <param name="ex"></param>
            <param name="template"></param>
            <param name="parmeters"></param>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Logging.IXLogger.Warning(System.String,System.Object[])">
            <summary>
            
            </summary>
            <param name="template"></param>
            <param name="parmeters"></param>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Logging.IXLogger.Warning(System.Exception,System.String,System.Object[])">
            <summary>
            
            </summary>
            <param name="ex"></param>
            <param name="template"></param>
            <param name="parmeters"></param>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Logging.IXLogger.Error(System.String,System.Object[])">
            <summary>
            
            </summary>
            <param name="template"></param>
            <param name="parmeters"></param>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Logging.IXLogger.Error(System.Exception,System.String,System.Object[])">
            <summary>
            
            </summary>
            <param name="ex"></param>
            <param name="template"></param>
            <param name="parmeters"></param>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Logging.IXLogger.Fatal(System.String,System.Object[])">
            <summary>
            
            </summary>
            <param name="template"></param>
            <param name="parmeters"></param>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Logging.IXLogger.Fatal(System.Exception,System.String,System.Object[])">
            <summary>
            
            </summary>
            <param name="ex"></param>
            <param name="template"></param>
            <param name="parmeters"></param>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Logging.IXLogger.LevelEnabled(XSockets.Core.Common.Utility.Logging.LogEventLevel)">
            <summary>
            
            </summary>
            <param name="level"></param>
            <returns></returns>
        </member>
        <member name="T:XSockets.Core.Common.Utility.Logging.LogEventLevel">
            <summary>
            To avoid dependencies to Serilog if you want to use another logger
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Utility.Logging.LogEventLevel.Verbose">
            <summary>
            
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Utility.Logging.LogEventLevel.Debug">
            <summary>
            
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Utility.Logging.LogEventLevel.Information">
            <summary>
            
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Utility.Logging.LogEventLevel.Warning">
            <summary>
            
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Utility.Logging.LogEventLevel.Error">
            <summary>
            
            </summary>
        </member>
        <member name="F:XSockets.Core.Common.Utility.Logging.LogEventLevel.Fatal">
            <summary>
            
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Utility.MessageQueue.IOfflineQueue">
            <summary>
            The interface for handling offline messages in XSockets.
            Implement this interface if you want to override the default in-memory plugin provided by XSocket.NET
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Utility.MessageQueue.IOfflineQueue.OfflineSubscribe``1(``0,System.String[])">
            <summary>
            Call this when the client leaves the controller (OnClose event in the controller)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="socket"></param>
            <param name="topics">All the topics to subscribe to</param>
        </member>
        <member name="M:XSockets.Core.Common.Utility.MessageQueue.IOfflineQueue.OfflineSubscribe``1(``0,System.Int32,System.String[])">
            <summary>
            Call this when the client leaves the controller (OnClose event in the controller).
            Provides and extra parameter that tell you for how long to store the data
            </summary>
            <typeparam name="T"></typeparam>
            <param name="socket"></param>
            <param name="storeForMs"></param>
            <param name="topics"></param>
        </member>
        <member name="M:XSockets.Core.Common.Utility.MessageQueue.IOfflineQueue.OnlinePublish``1(``0)">
            <summary>
            Call this when the client arrives at the controller (OnReopen event in the controller)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="socket"></param>
        </member>
        <member name="M:XSockets.Core.Common.Utility.MessageQueue.IOfflineQueue.Queue``1(``0,XSockets.Core.Common.Protocol.DeliveryType,XSockets.Core.Common.Socket.Event.Interface.IMessage,System.Func{``0,System.Boolean})">
            <summary>
            Tell the plugin to store a message for all the clients that are currently offline
            </summary>
            <typeparam name="T"></typeparam>
            <param name="socket"></param>
            <param name="deliveryType">If the delivery type if pub/sub or rpc</param>
            <param name="message"></param>
            <param name="func">A lambda expression to target a subset of the clients</param>
        </member>
        <member name="M:XSockets.Core.Common.Utility.MessageQueue.IOfflineQueue.Queue``1(``0,XSockets.Core.Common.Protocol.DeliveryType,XSockets.Core.Common.Socket.Event.Interface.IMessage)">
            <summary>
            Tell the plugin to store a message for all the clients that are currently offline
            </summary>
            <typeparam name="T"></typeparam>
            <param name="socket"></param>
            <param name="deliveryType">If the delivery type if pub/sub or rpc</param>
            <param name="message"></param>
        </member>
        <member name="T:XSockets.Core.Common.Utility.Observables.IConcurrentHashSet`1">
            <summary>
            Threadsafe HashSet of T
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Observables.IConcurrentHashSet`1.Add(`0)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Observables.IConcurrentHashSet`1.Clear">
            <summary>
            
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Observables.IConcurrentHashSet`1.Contains(`0)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Observables.IConcurrentHashSet`1.Remove(`0)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Observables.IConcurrentHashSet`1.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Utility.Observables.IConcurrentHashSet`1.Count">
            <summary>
            
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Utility.Observables.IXSocketObservable`2">
            <summary>
            An observer pattern to monitor objects
            </summary>
            <typeparam name="TK">Id type of the observable</typeparam>
            <typeparam name="T">Value type of the observable</typeparam>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Observables.IXSocketObservable`2.Subscribe(XSockets.Core.Common.Utility.Observables.IXSocketObserver{`0,`1})">
            <summary>
            Create a subscription on a observer object
            </summary>
            <param name="observer"></param>
            <returns></returns>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Observables.IXSocketObservable`2.Notify(`0,`1)">
            <summary>
            Notify for id TK with object T
            </summary>
            <param name="id"></param>
            <param name="loc"></param>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Observables.IXSocketObservable`2.Completed(`0,`1)">
            <summary>
            Tell that id TK is completed and pass in object of T
            </summary>
            <param name="id"></param>
            <param name="loc"></param>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Observables.IXSocketObservable`2.Completed(`0)">
            <summary>
            Tell that id TK is completed
            </summary>
            <param name="id"></param>
        </member>
        <member name="P:XSockets.Core.Common.Utility.Observables.IXSocketObservable`2.Id">
            <summary>
            Id of observable object
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Utility.Observables.IXSocketObservable`2.Observers">
            <summary>
            
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Utility.Observables.IXSocketObserver`2">
            <summary>
            
            </summary>
            <typeparam name="TK"></typeparam>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Observables.IXSocketObserver`2.OnError(System.Exception)">
            <summary>
            
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Observables.IXSocketObserver`2.OnNotify(`1)">
            <summary>
            
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Observables.IXSocketObserver`2.Unsubscribe">
            <summary>
            
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Observables.IXSocketObserver`2.Subscribe(XSockets.Core.Common.Utility.Observables.IXSocketObservable{`0,`1})">
            <summary>
            
            </summary>
            <param name="provider"></param>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Observables.IXSocketObserver`2.OnCompleted(`1)">
            <summary>
            
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Observables.IXSocketObserver`2.OnCompleted">
            <summary>
            
            </summary>
        </member>
        <member name="P:XSockets.Core.Common.Utility.Observables.IXSocketObserver`2.Id">
            <summary>
            
            </summary>
        </member>
        <member name="T:XSockets.Core.Common.Utility.Serialization.IXSocketJsonSerializer">
            <summary>
            The default serializer description
            You can replace teh XSockets serializer with another by implementing this interface
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Serialization.IXSocketJsonSerializer.SerializeToString``1(``0)">
            <summary>
            Serialize a object of type T to a JSON string
            </summary>
            <typeparam name="T">Type of the object</typeparam>
            <param name="obj">Object to serialize</param>
            <returns></returns>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Serialization.IXSocketJsonSerializer.SerializeToString(System.Object,System.Type)">
            <summary>
            Serialize a object to the type passed in to a JSON string
            </summary>
            <param name="obj">Object to serialize from</param>
            <param name="type">Type to serialize to</param>
            <returns></returns>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Serialization.IXSocketJsonSerializer.DeserializeFromString``1(System.String)">
            <summary>
            Deserialize JSON into the type T
            </summary>
            <typeparam name="T">The target type</typeparam>
            <param name="json">The JSON to convert to the type T</param>
            <returns></returns>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Serialization.IXSocketJsonSerializer.DeserializeFromString(System.String,System.Type)">
            <summary>
            Deserialize json into the type passed in
            </summary>
            <param name="json">The JSON representation of the type to serialize to</param>
            <param name="type">The type to convert to</param>
            <returns></returns>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Serialization.IXSocketJsonSerializer.DeserializeFromString(System.String,System.Reflection.ParameterInfo[])">
            <summary>
            Deserializes JSON into several types of the correct type based on parameterinfo passed in
            </summary>
            <param name="json">JSON representation of all parameters that we want out</param>
            <param name="parameterInfo">A list of parameterinfo that we want to have the JSON converted into</param>
            <returns></returns>
        </member>
        <member name="T:XSockets.Core.Common.Utility.Storage.IRepositoryInstance`2">
            <summary>
            A in-memory repository that can take any key TK and value T
            </summary>
            <typeparam name="TK">The key type</typeparam>
            <typeparam name="T">The value type</typeparam>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Storage.IRepositoryInstance`2.AddOrUpdate(`0,`1)">
            <summary>
            Adds a new instance of T or replaces the type if it exists
            </summary>
            <param name="key">the key to look for</param>
            <param name="entity">tne value to add or replace</param>
            <returns></returns>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Storage.IRepositoryInstance`2.Remove(`0)">
            <summary>
            Remove the instance key and value from the repository
            </summary>
            <param name="key">The key to look for</param>
            <returns>True if the key was found and item removed, otherwise false</returns>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Storage.IRepositoryInstance`2.Remove(System.Func{`1,System.Boolean})">
            <summary>
            Removes items that match the lambda expression
            </summary>
            <param name="f">Lambda expression for finding values to remove</param>
            <returns>The number of values removed by the lambda expression</returns>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Storage.IRepositoryInstance`2.RemoveAll">
            <summary>
            Clears the repository
            </summary>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Storage.IRepositoryInstance`2.Find(System.Func{`1,System.Boolean})">
            <summary>
            Find values based on a lambda expression
            </summary>
            <param name="f">Lambda expression for finding values</param>
            <returns>The vaules mathing the lambda expression</returns>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Storage.IRepositoryInstance`2.FindWithKeys(System.Func{`1,System.Boolean})">
            <summary>
            Find values based on a lambda expression and return the value and the key representation for each value
            </summary>
            <param name="f">Lambda expression for finding values</param>
            <returns>A dictionary representation of keys and values where the values match the lambda expression</returns>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Storage.IRepositoryInstance`2.GetAllWithKeys">
            <summary>
            Get all values and the key for each value
            </summary>
            <returns>A dictionary representation of keys and values</returns>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Storage.IRepositoryInstance`2.GetAll">
            <summary>
            Returns all values in the repository
            </summary>
            <returns></returns>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Storage.IRepositoryInstance`2.GetById(`0)">
            <summary>
            Find a specific value based on the key
            </summary>
            <param name="key">The key of type TK</param>
            <returns>The value of type T</returns>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Storage.IRepositoryInstance`2.GetByIdWithKey(`0)">
            <summary>
            Fins a specific value and the key based on the key
            </summary>
            <param name="key">The key of type TK</param>
            <returns>A KeyValuePair for the key TK and value T</returns>
        </member>
        <member name="M:XSockets.Core.Common.Utility.Storage.IRepositoryInstance`2.ContainsKey(`0)">
            <summary>
            Check if the repository contains a key TK
            </summary>
            <param name="key">The key to look for</param>
            <returns>True if found, otherwise false</returns>
        </member>
        <member name="P:XSockets.Core.Common.Utility.Storage.IRepositoryInstance`2.Item(`0)">
            <summary>
            Getter/Setter by key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
    </members>
</doc>
